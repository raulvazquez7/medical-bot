import os
import sys
# Add the root path so Python can find the 'src' module
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import argparse
import logging
import re
from docling.document_converter import DocumentConverter
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from src import config

# --- Logging Configuration ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler()
    ]
)

def clean_markdown_artifacts(raw_markdown: str) -> str:
    """
    Performs a programmatic cleanup of the Markdown generated by Docling,
    removing artifacts and normalizing the format.
    """
    logging.info("Cleaning artifacts from the generated Markdown...")
    
    # 1. Remove image placeholders
    cleaned_markdown = re.sub(r'^\s*<!-- image -->\s*\n?', '', raw_markdown, flags=re.MULTILINE)
    
    # 2. Normalize list markers (e.g., '- ' and '- -')
    cleaned_markdown = re.sub(r'^- \s*', '- ', cleaned_markdown, flags=re.MULTILINE)
    cleaned_markdown = re.sub(r'^- -\s*', '- ', cleaned_markdown, flags=re.MULTILINE)
    
    # 3. Consolidate multiple blank lines into a single one
    cleaned_markdown = re.sub(r'\n{3,}', '\n\n', cleaned_markdown)
    
    logging.info("Artifact cleanup completed.")
    return cleaned_markdown.strip()

def refine_hierarchy_with_llm(markdown_text: str) -> str:
    """
    Uses an LLM to analyze the Markdown and correct the hierarchy of
    the headers (#, ##, ###) to reflect a logical nesting.
    """
    logging.info(f"Using model '{config.PDF_PARSE_MODEL}' to refine header hierarchy...")
    
    try:
        llm = ChatGoogleGenerativeAI(model=config.PDF_PARSE_MODEL, temperature=0.0)
        
        system_prompt = """
You are an expert assistant in restructuring Markdown documents.
Your sole task is to analyze the Markdown of a medical leaflet and correct the hierarchy of the headers (`#`, `##`, `###`, etc.) to reflect a logical nesting.

Rules you must follow STRICTLY:
1.  Do NOT alter, add, or remove ANY word from the text content.
2.  Your only allowed modification is to change the number of hash marks (#) at the beginning of lines that are headers.
3.  Main titles (e.g., "1. What Nolotil is...") must be level 1 (`#`).
4.  Sections within a main title (e.g., "Warnings and precautions") must be level 2 (`##`).
5.  Subsections within a section (e.g., "Liver problems" within "Warnings") must be level 3 (`###`).
6.  Return the COMPLETE Markdown document with the corrected hierarchy.
"""
        
        human_prompt = "Please correct the hierarchy of the following Markdown:\n\n{markdown_content}"
        
        chat_prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("human", human_prompt),
        ])
        
        chain = chat_prompt | llm
        
        response = chain.invoke({"markdown_content": markdown_text})
        
        logging.info("Hierarchy has been successfully refined by the LLM.")
        return response.content
        
    except Exception as e:
        logging.error(f"Error during hierarchy refinement with LLM: {e}", exc_info=True)
        # In case of an error, return the original text to avoid losing previous work
        return markdown_text

def parse_pdf_with_docling(pdf_path: str, output_path: str, force_reparse: bool = False):
    """
    Orchestrates the hybrid pipeline: Docling for parsing, Python for cleaning, and LLM for hierarchy.
    """
    logging.info(f"--- Starting hybrid pipeline for: {os.path.basename(pdf_path)} ---")
    
    if not force_reparse and os.path.exists(output_path):
        logging.info(f"File '{output_path}' already exists. Skipping. Use --force-reparse to overwrite.")
        return

    if not os.path.exists(pdf_path):
        logging.error(f"Input file not found: {pdf_path}")
        return

    try:
        # STEP 1: Fast parsing with Docling
        logging.info("Step 1: Initializing Docling converter and processing the PDF...")
        converter = DocumentConverter()
        result = converter.convert(pdf_path)
        
        if not hasattr(result, "document") or result.document is None:
            logging.error("Docling did not return a processed document.")
            return

        if hasattr(result.document, "export_to_markdown"):
            raw_markdown_content = result.document.export_to_markdown()
        else:
            raise RuntimeError("Method 'export_to_markdown' not found. Check your Docling version.")
        
        # STEP 2: Programmatic cleaning of artifacts
        cleaned_markdown = clean_markdown_artifacts(raw_markdown_content)
        
        # STEP 3: Hierarchy refinement with LLM
        final_markdown = refine_hierarchy_with_llm(cleaned_markdown)
        
        # STEP 4: Save the final result
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(final_markdown)
        
        logging.info(f"Success! The final result has been saved to: {output_path}")

    except Exception as e:
        logging.error(f"An error occurred during the Docling pipeline: {e}", exc_info=True)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="""Hybrid script to convert a PDF to MD: Docling (parsing) + LLM (hierarchy)."""
    )
    parser.add_argument(
        "pdf_filename", 
        type=str, 
        help="The name of the PDF file to process (e.g., 'nolotil_575.pdf'). Must be in 'data'."
    )
    parser.add_argument(
        "--force-reparse",
        action="store_true",
        help="Forces the re-conversion of the PDF even if the Markdown file already exists."
    )
    args = parser.parse_args()

    # --- Path Construction ---
    input_pdf_path = os.path.join(config.DATA_PATH, args.pdf_filename)
    
    # We changed the model name we use, so we update the slug
    model_name_slug = f"docling_then_{config.PDF_PARSE_MODEL.replace('.', '-')}"
    output_md_filename = f"parsed_by_{model_name_slug}_{args.pdf_filename.replace('.pdf', '.md')}"
    output_md_path = os.path.join(config.MARKDOWN_PATH, output_md_filename)

    if not os.path.exists(config.MARKDOWN_PATH):
        os.makedirs(config.MARKDOWN_PATH)

    parse_pdf_with_docling(input_pdf_path, output_md_path, args.force_reparse)
